{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Render Room schemas into ER diagrams.</p> <p>Once you have a JSON representation of your Room exported schema, you can use <code>FloorPlan</code> to transform it into a DBML or DOT representation, or into SVG and PNG files, to then be checked back into the repository.</p> <p></p>"},{"location":"#diagram-rendering","title":"Diagram rendering","text":"<p>FloorPlan supports rendering to multiple formats, including SVG vectors, PNG and DOT, via its integration with the GraphViz visualization library.</p> <p>See an example of Tivi's's schema (v26) when rendered into a SVG file:</p> <p></p>"},{"location":"#diagram-metadata","title":"Diagram metadata","text":"<p>Some output formats allow for metadata to be attached to the ER diagram rendering. When outputting to SVG, FloorPlan will include supplementary information on entities, if available.</p> <p></p>"},{"location":"#database-markup-language-dbml","title":"Database Markup Language (DBML).","text":"<p>DBML (Database Markup Language) is an open-source DSL language designed to define and document database schemas and structures. It is designed to be simple, consistent and highly-readable.</p> <p>FloorPlan provides a translation mechanism from the input database schemas into DBML, that can be later used for other interesting applications, like ER diagram rendering or in as an input for Pull Request revision on a development process.</p>"},{"location":"#dbml-parser","title":"DBML parser","text":"<p>With a few manual tweaks, DBML can also be used directly as an input to the rendering mechanism, by skipping the pipeline's JSON-consumption step.</p>"},{"location":"#dbdiagram","title":"dbdiagram","text":"<p>dbdiagram is a free, simple tool to draw ER diagrams, that can be used to render the DBML output of FloorPlan.</p> <p></p> <p>For instance, when translating Tivi's schema (v26), this is the rendered output in dbdiagram:</p> <p></p> <p>Note</p> <p>FloorPlan and its developers are in no way associated to dbdiagram.</p>"},{"location":"architecture/","title":"Modularization","text":"<p>FloorPlan's source code is distributed across multiple modules, each responsible for one aspect of domain modeling or one stage of the processing pipeline.</p> <p></p>"},{"location":"architecture/#floorplan-cli","title":"<code>floorplan-cli</code>","text":"<p>Home for the command line argument parsing logic, and general aspects of application bootstrapping.</p> <p>The <code>cli</code> module is one possible interaction point between users and FloorPlan, but can be replaced by other user interfaces, like a Gradle plug-in or potentially a fully-fledged GUI application.</p>"},{"location":"architecture/#dbml-models","title":"DBML models","text":"<p>Barebones Kotlin models of the DBML object concepts.</p> <p>This module has no logic in it other than housing the domain representations of Tables, References, Indexes, etc.</p>"},{"location":"architecture/#processing-pipeline","title":"Processing pipeline","text":""},{"location":"architecture/#consumer","title":"Consumer","text":"<p>This stage of the processing pipeline is responsible for translating the user input files into DBML models, representing each of the entities and relationships.</p> <p>So far, FloorPlan processes:</p> <ul> <li>Room schemas, by deserializing their JSON representations (see sample) on the <code>:room-consumer</code> module.</li> <li>SQLite <code>db</code> files, by connecting to them via a JDBC driver and query metadata of entities and relationships.</li> <li>DBML schema files.</li> </ul>"},{"location":"architecture/#visualization","title":"Visualization","text":"<p>Depending on the output file format, FloorPlan uses different mechanisms to translate the input.</p> <p>The DBML models are rendered as text by a module of its own, while FloorPlan relies on GraphViz visualization library to render image representations.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#04","title":"0.4","text":"<ul> <li>Gradle Plugin: Take in DBML files as input.</li> <li>General: FloorPlan CLI is now distributed via homebrew! Checkout the documentation for more information.</li> <li>General: Update to Kotlin 1.5.</li> </ul>"},{"location":"changelog/#03","title":"0.3","text":"<ul> <li>FloorPlan engine: Allow for multi-format output<ul> <li>A user can now specify a list of output formats for FloorPlan to output to.</li> </ul> </li> <li>FloorPlan engine: Crow's Foot notation</li> <li>CLI: Specify a directory for output instead of file<ul> <li>With multi-format output, the CLI will now require an output directory in its argument list to write all renderings into.</li> </ul> </li> <li>CLI: Rewrite using Clikt<ul> <li>Follows argument parsing standards</li> <li>Allows for multiple option definition for argument parsing</li> <li>Help and Version commands</li> </ul> </li> <li>Parser: Parse multi-column primary key and composite indexes</li> <li>Parser: Include table notes and table aliases in output</li> <li>General: Update to Kotlin 1.4</li> </ul>"},{"location":"changelog/#02","title":"0.2","text":"<ul> <li>Add SQLite-based consumer, with driver to connect to <code>.db</code> files.<ul> <li>We now allow for rendering schemas for popular SQLite ORMs, such as SQLDelight and Core Data.</li> </ul> </li> <li>Add DBML consumer, to allow for rendering schemas directly from <code>.dbml</code> files.</li> <li><code>:dbml-parser</code> now parses <code>Index</code>es.</li> </ul>"},{"location":"changelog/#01","title":"0.1","text":"<p>Initial release.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to FloorPlan!</p>"},{"location":"contributing/#setup","title":"Setup","text":"<ul> <li>Check out the project</li> <li>Download IntelliJ IDEA or Android Studio and import it.</li> </ul>"},{"location":"contributing/#build","title":"Build","text":"<ul> <li>Build the CLI and its subprojects with <code>./gradlew :floorplan-cli:build</code>.</li> <li>Build the Gradle Plugin:<ul> <li>Publish a snapshot to your local maven repository: <code>./gradlew :floorplan-gradle-plugin:publishToMavenLocal</code></li> <li>Enable the sample app building: <code>echo floorplan.includeSampleApp=true &gt;&gt; ~/.gradle/gradle.properties</code></li> <li>(Optionally) Trigger the task on the sample app with <code>./gradlew :sample-android-project:generateFloorPlan</code></li> </ul> </li> </ul> <p>Note: Gradle Plugin - workflow</p> <p>The gradle plugin development workflow requires republishing of the latest builds to <code>mavenLocal</code> after each code change. You will need to the deployment steps above if you want to manually test the changes in an end-to-end fashion with the help of the sample Android application.</p>"},{"location":"contributing/#tests","title":"Tests","text":"<p>The project is unit tested and has integration tests for its Gradle plugin. These can be run via Gradle with: <pre><code>gradlew test\n</code></pre></p> <p>You can also run only the Gradle Plugin tests by specifying that task explicitly:</p> <pre><code>gradlew :floorplan-gradle-plugin:test\n</code></pre>"},{"location":"contributing/#deploying-the-docs-locally","title":"Deploying the docs locally","text":"<p>Install <code>mkdocs</code> and the required extensions:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>Deploy it locally:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"contributing/#release","title":"Release","text":"<ul> <li>Create a local release branch from <code>master</code> <pre><code>git checkout master\ngit pull\ngit checkout -b release_&lt;next-release-version&gt;\n</code></pre></li> </ul> <ul> <li>Update <code>floorPlanVersion</code> in the <code>versioning.gradle</code> (remove <code>-SNAPSHOT</code>) <pre><code>floorPlanVersion = \"&lt;next-release-version&gt;\"\n</code></pre></li> </ul> <ul> <li>Update <code>docs/changelog.md</code> after checking out all changes:<ul> <li>https://github.com/julioz/FloorPlan/compare/v<code>&lt;current-release-version&gt;</code>...master</li> </ul> </li> </ul> <ul> <li>Take one last look <pre><code>git diff\n</code></pre></li> </ul> <ul> <li>Commit all local changes <pre><code>git commit -am \"Prepare &lt;next-release-version&gt; release.\"\n</code></pre></li> </ul> <ul> <li>Perform a clean build <pre><code>./gradlew clean\n./gradlew build\n</code></pre></li> </ul> <ul> <li>Create a tag and push it <pre><code>git tag v&lt;next-release-version&gt;\ngit push origin v&lt;next-release-version&gt;\n</code></pre></li> </ul> <ul> <li>Create a new GitHub release based on that tag, and upload the zip and tar distributions</li> </ul> <ul> <li>Make sure you have valid credentials in <code>~/.gradle/gradle.properties</code> to upload the artifacts <pre><code>SONATYPE_NEXUS_USERNAME=\nSONATYPE_NEXUS_PASSWORD=\n</code></pre></li> </ul> <ul> <li>Upload the artifacts to Sonatype OSS Nexus <pre><code>./gradlew publish --no-daemon --no-parallel\n</code></pre></li> </ul> <ul> <li>Release to Maven Central<ul> <li>Login to Sonatype OSS Nexus</li> <li>Click on Staging Repositories</li> <li>Scroll to the bottom, you should see an entry named <code>comjuliozynger-XXXX</code></li> <li>Check the box next to the <code>comjuliozynger-XXXX</code> entry, click Close then Confirm</li> <li>Wait a bit, hit Refresh, until the Status for that column changes to Closed.</li> <li>Check the box next to the <code>comjuliozynger-XXXX</code> entry, click Release then Confirm</li> </ul> </li> </ul> <ul> <li>Release to Gradle Plugin Portal <pre><code>./gradlew publishPlugins\n</code></pre></li> </ul> <ul> <li>Release via homebrew <pre><code>scripts/release_homebrew.sh\n</code></pre></li> </ul> <ul> <li>Merge the release branch to master <pre><code>git checkout master\ngit pull\ngit merge --no-ff release_&lt;next-release-version&gt;\n</code></pre></li> <li>Update <code>floorPlanVersion</code> in <code>versioning.gradle</code> (increase version and add <code>-SNAPSHOT</code>) <pre><code>floorPlanVersion = \"REPLACE_WITH_NEXT_VERSION_NUMBER-SNAPSHOT\"\n</code></pre></li> </ul> <ul> <li>Commit your changes <pre><code>git commit -am \"Prepare for next development iteration.\"\n</code></pre></li> </ul> <ul> <li>Push your changes <pre><code>git push\n</code></pre></li> </ul>"},{"location":"gradle-plugin/","title":"FloorPlan as a Gradle Plugin","text":""},{"location":"gradle-plugin/#apply-the-plugin","title":"Apply the plugin","text":"<p>Apply the gradle plugin in your root <code>build.gradle</code> file:</p> <pre><code>buildscript {\n  dependencies {\n    classpath \"com.juliozynger.floorplan:floorplan-gradle-plugin:&lt;version&gt;\"\n  }\n}\n</code></pre> <p>and in the modules you want <code>FloorPlan</code>'s Gradle task to exist.</p> <p>For example, in an Android application module:</p> <pre><code>plugins {\n    id 'com.android.application' // could be library or any other module\n    id 'com.juliozynger.floorplan'\n}\n</code></pre>"},{"location":"gradle-plugin/#gradle-extension","title":"Gradle extension","text":"<p>Configure FloorPlan's Gradle extension by definining a <code>floorPlan</code> block:</p> <pre><code>floorPlan {\n    schemaLocation = \"$projectDir/schemas\".toString()\n    outputLocation = \"$projectDir/floorplan-output\".toString()\n    outputFormat {\n        svg {\n            enabled = true\n        }\n    }\n}\n</code></pre>"},{"location":"gradle-plugin/#output-formats","title":"Output formats","text":"<p>FloorPlan is able to output different file formats.</p> <p>Take a look at what a full configuration would look like, defining <code>DBML</code> and <code>SVG</code> as output formats (and providing extra configurations for <code>DBML</code>):</p> <pre><code>floorPlan {\n    schemaLocation = \"$projectDir/schemas\".toString()\n    outputLocation = \"$projectDir/floorplan-output\".toString()\n    outputFormat {\n        dbml {\n            enabled = true\n            creationSqlAsTableNote = false\n            renderNullableFields = false\n        }\n        svg {\n            enabled = true\n        }\n        png {\n            enabled = false\n        }\n        dot {\n            enabled = false\n        }\n    }\n}\n</code></pre>"},{"location":"gradle-plugin/#erd-notation","title":"ERD Notation","text":"<p>FloorPlan supports rendering entity-relationship diagrams using different notations.</p> <pre><code>floorPlan {\n    schemaLocation = \"$projectDir/schemas\".toString()\n    outputLocation = \"$projectDir/floorplan-output\".toString()\n    notation = \"crowsfoot\"\n    outputFormat {\n        svg {\n            enabled = true\n        }\n    }\n}\n</code></pre> <p>Check this page for the supported notations list.</p>"},{"location":"gradle-plugin/#generate-floor-plan","title":"Generate Floor Plan","text":"<p>Once everything is setup, you can finally run FloorPlan to translate database schemas into ER diagrams.</p> <p>For example, to generate the diagrams associated to the <code>sample-android-project</code> module schemas, we can run:</p> <pre><code>./gradlew :sample-android-project:generateFloorPlan\n</code></pre>"},{"location":"intellij-plugin/","title":"FloorPlan as an IntelliJ Plugin","text":"<p>FloorPlan has a (incubating) plug-in for IDEs based on the IntelliJ platform (IDEA, Android Studio, AppCode, CLion, etc.)</p> <p>The plug-in will scan the file system for FloorPlan's output files and display them as a gutter action in the IDEA sidebar for extra discoverability and easy access.</p> <p></p>"},{"location":"intellij-plugin/#download-and-install","title":"Download and install","text":"<p>Given the incubating nature of the plugin, it is not distributed through JetBrains plug-in repository. Download the plug-in <code>zip</code> file and follow the 'instalation from disk' steps.</p>"},{"location":"intellij-plugin/#building","title":"Building","text":"<p>The source code is available in the <code>:floorplan-intellij-plugin</code> module. It relies on Gradle and the <code>intellij</code> DevKit to manipulate the PSI tree.</p> <p>Deploy an artifact for local debugging with <code>./gradlew runIde</code>.</p> <p>For manual distribution or local installation, invoke <code>gradlew buildPlugin</code> target to create the plugin distribution. The resulting <code>JAR</code>/<code>ZIP</code> is located in <code>build/distributions</code> and can then be installed.</p>"},{"location":"run/","title":"Run FloorPlan from the command line","text":"<p>After checking out this repository, make sure you have Gradle installed and run: <pre><code>gradlew run --args=\"&lt;path-to-schema-file&gt;\"\n</code></pre></p>"},{"location":"run/#installation-with-homebrew","title":"Installation with Homebrew","text":"<p>On MacOS you can install <code>FloorPlan</code> also with Homebrew <pre><code>brew install julioz/tap/floorplan\n</code></pre></p>"},{"location":"run/#command-line-arguments","title":"Command-line arguments","text":""},{"location":"run/#output-format-format-f","title":"Output format (<code>--format</code>, <code>-f</code>)","text":"<p>FloorPlan can render many output formats, specified by the <code>--format</code> argument:</p> <pre><code>gradlew run --args=\"&lt;path-to-schema-file&gt; --format &lt;output-format&gt;\"\n</code></pre> <p>Currently, the supported formats are:</p> <ul> <li>DBML</li> <li>SVG</li> <li>PNG</li> <li>DOT</li> </ul> <p>Info</p> <p>Multiple output formats can be specified through a comma-separated list: <pre><code>gradlew run --args=\"&lt;path-to-schema-file&gt; --format &lt;format1&gt;,&lt;format2&gt;,&lt;format3&gt;\"\n</code></pre></p> <p>Info</p> <p>When not present, DBML is picked as default value as output format.</p> <p>Warning</p> <p>Some arguments are restricted to their combination with the specified output format. Refer to the individual argument documentation to verify its availability.</p>"},{"location":"run/#write-output-to-directory-output-o","title":"Write output to directory (<code>--output</code>, <code>-o</code>)","text":"<p>FloorPlan will write its output file(s) into the specified directory. The directory will be created if it doesn't exist and the input filename will be used to name the output files.</p> <pre><code>gradlew run --args=\"&lt;path-to-schema-file&gt; --output &lt;path-to-output-directory&gt;\"\n</code></pre>"},{"location":"run/#erd-notation-notation-n","title":"ERD Notation (<code>--notation</code>, <code>-n</code>)","text":"<p>FloorPlan supports rendering entity-relationship diagrams using different notations.</p> <pre><code>gradlew run --args=\"&lt;path-to-schema-file&gt; --notation &lt;notation-identifier&gt;\"\n</code></pre>"},{"location":"run/#supported-notations","title":"Supported notations","text":"Name Identifier Screenshot Simplified Chen (default) <code>chen</code> Crow's Foot <code>crowsfoot</code>"},{"location":"run/#add-creation-sql-as-table-note-creation-sql-as-table-note-ctn","title":"Add <code>CREATION SQL</code> as Table note (<code>--creation-sql-as-table-note</code>, <code>-ctn</code>)","text":"<p>This option is disabled by default since it can be quite verbose and would 'duplicate' what a UI rendering tool (better) provides. Opt-in by specifying:</p> <pre><code>gradlew run --args=\"&lt;path-to-schema-file&gt; --creation-sql-as-table-note\"\n</code></pre> <p>Availability: DBML</p> <p>Only available when the output format is DBML.</p>"},{"location":"run/#render-nullable-fields-in-data-types-render-nullable-fields-rnf","title":"Render nullable fields in data types (<code>--render-nullable-fields</code>, <code>-rnf</code>)","text":"<p>This option is disabled by default, opt-in with:</p> <pre><code>gradlew run --args=\"&lt;path-to-schema-file&gt; --render-nullable-fields\"\n</code></pre> <p>Availability: DBML</p> <p>Only available when the output format is DBML.</p>"},{"location":"recipes/android-room/","title":"FloorPlan &amp; Room","text":"<p>The Room persistence library provides an abstraction layer over SQLite to allow for more robust database access while harnessing the full power of SQLite.</p> <p>Room can export your database's schema information into a <code>JSON</code> file at compile time. To export the schema, set the <code>room.schemaLocation</code> annotation processor property (or <code>kapt</code>, if you use Kotlin) in your <code>build.gradle</code> file.</p> <p>The <code>JSON</code> schemas can, then, be passed to FloorPlan as an input parameter for its rendering generation. Here we see an example with FloorPlan's Gradle Plugin: <pre><code>android {\n    ...\n    defaultConfig {\n        ...\n        javaCompileOptions {\n            annotationProcessorOptions {\n                arguments += [\"room.schemaLocation\":\n                             \"$projectDir/schemas\".toString()]\n            }\n        }\n    }\n}\n\n...\n\nfloorPlan {\n  schemaLocation = \"$projectDir/schemas\".toString()\n  ...\n}\n</code></pre></p>"},{"location":"recipes/mysql-postgres/","title":"MySQL &amp; Postgres","text":"<p>DBML comes with a built-in CLI which can be used to convert between different formats from the command line. We can use it in par with FloorPlan to generate ER diagrams for both MySQL and Postgres databases.</p> <p>First, we must translate our <code>.sql</code> files into <code>.dbml</code> files by using the CLI tools.</p> <p>Install DBML's CLI with:</p> <pre><code>npm install -g @dbml/cli\n</code></pre> <p>And convert your schema dump:</p> <pre><code># for a Postgres DB:\nsql2dbml --postgres dump.sql -o mydatabase.dbml\n\n# or for MySQL\nsql2dbml --mysql dump.sql -o mydatabase.dbml\n</code></pre> <p>The <code>.dbml</code> output can be passed into <code>FloorPlan</code> for the ER diagram generation.</p>"},{"location":"recipes/sqldelight/","title":"FloorPlan &amp; SQLDelight","text":"<p>In order to use SQLDelight schemas as input to FloorPlan, make sure you are on a recent version of library (&gt;=1.0).</p> <p>When applying SQLDelight's Gradle plugin, specify the following gradle extension to configure it to output <code>.db</code> files.</p> <pre><code>sqldelight {\n    &lt;databaseName&gt; {\n        packageName = \"&lt;fully qualified package name to where the database is generated&gt;\"\n        schemaOutputDirectory = file(\"&lt;output directory for the db file&gt;\")\n    }\n}\n</code></pre> <p>Once done, running <code>./gradlew &lt;module&gt;:tasks</code> will uncover a generateSchema gradle task per build type (usually <code>debug</code>, <code>release</code>, etc.).</p> <pre><code>./gradlew generate&lt;buildType&gt;&lt;projectName&gt;Schema\n</code></pre> <p>will output a <code>.db</code> file can be used as an input to <code>FloorPlan</code>, via its CLI or Gradle Plugin interfaces.</p> <p>Note</p> <p>Read more about SQLDelight's configuration on the project's website.</p>"}]}